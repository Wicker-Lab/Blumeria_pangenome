#!/usr/bin/perl

use lib '/home/wicker/data/WICKERsoft/';
use Biomodule;
use GD;


if (@ARGV < 3) {
	print "1.= .blast_plot\n";
	print "2.= minimal identity\n";
	print "3.= scale unit in kb\n";
	print "4.= kb to add to scale (optional), or -s to supress pop-up\n";
	print "5.= width of picture\n";
	exit;
	}

$min_sim = $ARGV[1];
$out_name = $ARGV[0];
$add_pos = 0;
if ($ARGV[3] =~ /^\d+$/) {
	$add_pos = $ARGV[3];
	}
$out_name =~ s/blast_plot/png/;

$wide = 800;
if ($ARGV[4]) {
	$wide = $ARGV[4];
	}

# get all info from blast plot file
open(IN,"$ARGV[0]");
while (<IN>) {

	($nam,$l) = /INFILE_1\s+(\S+)\s+(\S+)\s/;
	if ($nam) {
		$name1 = $nam;
		$len1 = $l;
		}

        ($nam,$l) = /INFILE_2\s+(\S+)\s+(\S+)\s/;
        if ($nam) {
                $name2 = $nam;
                $len2 = $l;
                }
	
	($be1,$en1,$be2,$en2,$sim) = /^(\d+)-(\d+)\s+(\d+)-(\d+)\s+([\d\.]+)%/;
	if ($en1) {
		if ($sim >= $min_sim) {
		$data[$count][0] = $be1;
		$data[$count][1] = $en1;
		$data[$count][2] = $be2;
		$data[$count][3] = $en2;
		$data[$count][4] = $sim;
		$count++;
		}
		}

	}
close(IN);


# calculate x-zoom factor and image height
$zoom = $len1/$wide;
$high = int($len2/$zoom);

$x_base = 50;
$y_base = 50;

print "$wide x $high\n";

# create a new image
$img_x = $wide +3*$x_base;
$img_y = $high +1.5*$y_base;
$img = new GD::Image($img_x,$img_y);

# allocate some colors
$white = $img->colorAllocate(255,255,255);
$black = $img->colorAllocate(0,0,0);       
$red = $img->colorAllocate(255,0,0);      
$blue = $img->colorAllocate(0,0,255);
$gray = $img->colorAllocate(170,170,170);

# make red gradient and color legend
@red = ();
$count_col =0;
%red = ();
$col_step = (100-$min_sim)/25;
print "col step = $col_step\n";
$time = 5;

$x1 = $x_base+$wide+20;
$y1 = $y_base+10;
$lab = "Identity";
$img->string(gdLargeFont,$x1,$y1,$lab,$black);

for($i=0;$i<=255;$i+=10) {
        $r = $i;
        $g = 0;
        $b = 0;
        $name = "red$count_col";
        $col = $img->colorAllocate($r,$g,$b);
        $red{$name} = $col;

        $fill = $red{$name};

	$sim = (int(($min_sim+$count_col*$col_step)*10))/10;

	$x1 = $x_base+$wide+20;
	$x2 = $x1+15;
	$x3 = $x1+25;
	$y1 = $y_base+$count_col*8+30;
	$y2 = $y1+7;


	$img->filledRectangle($x1,$y1,$x2,$y2,$fill);

	if ($time > 4) {
		$val = sprintf("%.1f",$sim);
		$lab = "$val %";
		$img->string(gdSmallFont,$x3,$y1,$lab,$black);
		$time =0;
		}
	$time ++;

	$count_col++;

	print "$i\t$name\t$r,$g,$b\t$sim\t$x1,$y1,$x2,$y2\n";

        }




# draw labels
$midx = int($wide/2);
$midy = int($high/2);
$img->string(gdLargeFont,$x_base,10,$name1,$black);
$img->stringUp(gdLargeFont,10,$high,$name2,$black);

# determine order of magnitude to set scale step
$log = log($len1)/log(10);
$pot = (int($log))-1;
$step = 10**$pot;
print "log = $log\t==> step = $step\n";

if (($len1 > 2000000) && ($len1 < 5000000)) {
	$step = 500000;
	}

if ($ARGV[2]) {
	$step = $ARGV[2]*1000;
	}


# draw x scale and grid
#$step = int($len1/10);
for($i=0;$i<=$len1;$i+=$step) {
	$x1 = $x_base+int($i/$zoom);
	$y1 = $y_base;
	$y2 = $y_base-3;
	$val = $i+$add_pos;
	if ($val > 1000) {
		$val = int(($i+$add_pos)/1000);
		}
	
	$img->line($x1,$y1,$x1,$y2,$black);
	$img->string(gdSmallFont,$x1,$y_base-15,$val,$black);
	
	# make grid
	$y3 = $y_base+$high;
	$img->line($x1,$y1,$x1,$y3,$gray);


	}

# draw y scale
for($i=0;$i<=$len2;$i+=$step) {
        $y1 = $y_base+int($i/$zoom);
        $x1 = $x_base;
        $x2 = $x_base-3;
	$val = $i+$add_pos;
        if ($val > 1000) {
                $val = int(($i+$add_pos)/1000);
                }
        $img->line($x1,$y1,$x2,$y1,$black);
        $img->stringUp(gdSmallFont,$x_base-15,$y1,$val,$black);


        # make grid
        $x3 = $x_base+$wide;
        $img->line($x1,$y1,$x3,$y1,$gray);

        }

# draw frame for dotplot
$x1 = $x_base;
$x2 = $x_base+$wide;
$y1 = $y_base;
$y2 = $y_base+$high;
$img->rectangle($x1,$y1,$x2,$y2,$black);




# loop through blast hits and draw lines
for($i=0;$i<$count;$i++) {
	$x1 = $x_base+int($data[$i][0]/$zoom);
	$x2 = $x_base+int($data[$i][1]/$zoom);
	$y1 = $y_base+int($data[$i][2]/$zoom);
	$y2 = $y_base+int($data[$i][3]/$zoom);

	# make heat code
	$sim = $data[$i][4];
	$diff = $sim-$min_sim;
	$col_step = 25/(100-$min_sim);
	$val = int($diff*$col_step);
	$col = "red$val";
	$fill = $red{$col};
	#print "$sim\t$diff\t==>\t$val\t$col\n";
	#$delta = (100-$sim*5);
	#$fill = $img->colorAllocate($delta,0,0);

	if ($sim > 99) {
		$col = "red0";
	#	$fill = $red{$col};
		}
	#$fill = $black;

	$img->line($x1,$y1,$x2,$y2,$fill);
	}
	



# convert into png data
$out = "img.png";
$out = $out_name;
open $png, '>', $out or die;
binmode $png;
print $png $img->png;

# open image
print "opening image, please wait\n";

# suppress pop-up, if wanted
unless ($ARGV[3] eq '-s') {
	`eog $out`;
	}
print "wrote $out\n";






























