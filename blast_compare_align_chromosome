#!/usr/bin/perl

use lib '/home/wicker/data/WICKERsoft/';
use Biomodule;

`cp /home/wicker/data/WICKERsoft/BLOSUM62 .`;

if (@ARGV < 5) {
	print "1.arg = chromosome segment 1\n";
	print "2.arg = chromosome segment 2\n";
	print "3.arg = size of segment for blasts\n";
	print "4.arg = sliding step\n";
	print "5.arg = range of comparison in Mb (e.g. 0-100 for large chromosomes)\n";
	exit;
	}

	
$open = 50;
$ext = 0.01;

$chr1 = $ARGV[0];
$chr2 = $ARGV[1];
$slice = $ARGV[2];
$step = $ARGV[3];
$step_orig = $ARGV[3];
$blast = "blastn";

$min_len = int($slice/3);
$min_sim = 80;

# make log for positions to assemble no-hit fragments
$log3 = "log_no_hit_segments_$ARGV[0]";
# .... collect, if there are 2 consecutive no-hits
$min_no_hit = 3;
open(LOG3,">$log3");


($min,$max) = ($ARGV[4] =~ /^(\d+)-(\d+)/);
$min *= 1000000;
$max *= 1000000;


# check if database exists
&check_db;

$log2 = "log_chr_comp_$chr1\__x__$chr2\.tab";
open(LOG2,">$log2");


print "get chromosome sizes\n";
($dna1) = &pure_sequence($chr1);
($dna2) = &pure_sequence($chr2);
$len1 = length($dna1);
$len2 = length($dna2);

if ($max > $len1) {
	$max = $len1;
	}

print "$chr1\t$len1 bp\n";
print "$chr2\t$len2 bp\n";
print LOG2 "CHR1=$chr1 LEN1=$len1\tCHR2=$chr2\tLEN2=$len2\n";

print "align $min-$max\n";


# walk through seq1 in segments
$go = 0;
$count_no_hit = 0;
$count_no_reg = 0;

for($i=$min;$i<($max-$step);$i+=$step) {


	$seq = substr($dna1,$i,$slice);
	$count++;
	$name = "$chr1\_x_$chr2\_$count";

	$flag = "NO HIT";

	$hit_yes = 0;

	# call blast and blast parser	
	&flow_sort;

	# check if there is a large insertion (difference in distances to the previous hit)
	$diff1 = $beg1-$be1_old;
	$diff2 = $be2-$be2_old;


	print "$count\t$count_hit\t$name\t$flag \n";

	$delta = abs($diff1-$diff2);

	# only accept pairs that differ my max 40% in abolute position 
	# if there is a hit
	if ($beg1 > 0) {
	$abs_dist = abs($beg1-$be2);
	$rel_dist = $abs_dist/$beg1;

	# ignore very large jumps and inverted hits, and hits that are in different parts of chromosome
	if (($delta > 600) && ($delta < 20000) && ($ori eq 'for') && ($ori_old eq 'for') && ($rel_dist < 0.4)) {
		print "JUMP\t$delta\n";
		#&align_indel;
		}
	}

	# memorize previous positions
	$be1_old = $beg1;
	$en1_old = $end1;
	$be2_old = $be2;
	$en2_old = $en2;
	$ori_old = $ori;

	if ($count > 7) {
#		exit;
		}
	}


#`rm_db $chr2`;

# align region with large indel with smith-waterman  ++++++++++++++++++++++
# this is only used to characterize TE and other large insertions
sub align_indel {

# add 1000 to each en to provide a better anchor	
$be_aln1 = $be1_old -1000;
$en_aln1 = $end1+1000;

$be_aln2 = $be2_old -1000;
$en_aln2 = $en2+1000;

$len_aln1 = $en_aln1-$be_aln1;
$len_aln2 = $en_aln2-$be_aln2;

print "compare:\n";
print "$chr1\t$be_aln1\t$en_aln1\t$len_aln1\n";
print "$chr2\t$be_aln2\t$en_aln2\t$len_aln2\n";

# security patch in case len_aln < 0 or extremely long
if (($len_aln1 > 0) && ($len_aln2 > 0) && ($len_aln1 <30000) &&( $len_aln1< 30000)) {


# extract substrings and make fasta files for alignment
$sub1 = substr($dna1,$be_aln1,$len_aln1);
$sub2 = substr($dna2,$be_aln2,$len_aln2);

$kb1 = int($be_aln1/1000);
$kb2 = int($be_aln2/1000);

$kb1 = sprintf("%06d",$kb1);
$kb2 = sprintf("%06d",$kb2);

$name1 = "$chr1\_$kb1";
$name2 = "$chr2\_$kb2";

open(ALN1,">$name1");
open(ALN2,">$name2");

($fasta1) = &mk_fasta($sub1);
print ALN1 ">$name1\n$fasta1\n";
close(ALN1);

($fasta2) = &mk_fasta($sub2);
print ALN2 ">$name2\n$fasta2\n";
close(ALN2);

$out_pair = "$name1\_x_$name2\.pair";

print "align:\n";
print "$name1\t$len_aln1 bp\n";
print "$name2\t$len_aln2 bp\n";

`water $name1 $name2 -gapopen=$open -gapextend=$ext -outfile=$out_pair`;

print "wrote $out_pair\n";

`rm $name1 $name2`;

} # end secure patch

}


# +++++++++++++++++++++++++++++++++++++++
# rund blast of chr segment againt the other chromosome
sub flow_sort {

$time_out++;

($fasta) = &mk_fasta($seq);

open(OUT,">$name");
print OUT ">$name\n$fasta\n";
close (OUT);

$out = "$name\.blastn";
$db = "/home/wicker/data/databases/blast_databases/$chr2";


`blastall -p $blast -d $db -i $name -F T -o $out`;

(@test) = &parse_blast($out);

# just look at the best hit
($ID,$rem,$s_size) = ($test[0] =~ /ID=([^;]+);([^;]+);(\d+)/);
(@data) = ($test[0] =~ /^(data=.+)$/gm);

($Eval,$sim,$be1,$en1,$be2,$en2,$seq1,$seq2) = ($data[0] =~
/data=[^;]+;([^;]+);([^;]+);([^;]+);([^;]+);([^;]+);([^;]+);([^;]+);([^;]+)/);

$diff = abs($be1-$en1)+1;

$pot = '';
($pot) = ($Eval =~ /e-(\d+)/);

if ($Eval eq '0.0') {
        $pot = 100;
        }

if (($diff > $min_len) && ($sim >= $min_sim)) {

	$count_hit++;
	$ori = "for";
	if (($be1 > $en1) || ($be2 > $en2)){
		$ori = "rev";
		}

	# calculate absolute position of bet hits	
	$beg1 = $be1+$i;
	$end1 = $en1+$i;

	# get TI/TV and indentity
        &process_aln;


	#print "$count\t$count_hit\t$name\t$beg1\t$be2\t$diff\t$sim%\t$ori\n";
	print LOG2 "$name\t$beg1\t$be2\t$diff\t$sim%\t$ori\t$len_aln\t$ti\t$tv\t$date\t$std\n";
	$flag = "$beg1-$end1\t$be2-$en2\t$diff\t$sim%\t$ori\t$len_aln\t$ti\t$tv\t$date\t$std";

	$hit_yes = 1;

	#print LOG "$name,$be1,$be2,$len_align,$match,$rel,$ori\n"
	} 

`rm $out`;
`rm $name`;

} # -----------------------------------------------


# extract TI+TV from alignments for dating +++++++++++++++++++++++++
sub process_aln {

# replace lower case letters from low-complexity filtering 
$seq1 =~ tr/a-z/A-Z/;
$seq2 =~ tr/a-z/A-Z/;

@seq1 = split('',$seq1);
@seq2 = split('',$seq2);

$len = @seq1;
$len_aln = 0;
$ti = 0;
$tv = 0;
$id = 0;

for ($a =0;$a<$len;$a++){

                if (($seq1[$a] ne '-') && ($seq2[$a] ne '-')&&($seq1[$a] ne 'N') && ($seq2[$a] ne 'N')){
                        $len_aln++;
                        if ($seq1[$a] eq $seq2[$a]){
                                $id++;
                                } else {
                                # determine substitition kind
                                &subst_matrix;
                                $SNP[$a]++;
                                }
                        }

                }


if ($len_aln > 0){
        $sim = (int($id/$len_aln*10000))/100;
        } else {
        $sim = "0";
        }

	
if ($len_aln > 0){

	# calculate standard divergece +++++++++++++++++++++++++++
	(@date) = &seq2date($len_aln,$ti,$tv);
	$date = (int($date[0]/1000))/1000;
	$std = (int($date[1]/1000))/1000;
	}


}




# +++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
sub subst_matrix {

if (($seq1[$a] eq 'A') && ($seq2[$a] eq 'G')) { $ti++; }
elsif (($seq1[$a] eq 'G') && ($seq2[$a] eq 'A')) { $ti++; }
elsif (($seq1[$a] eq 'C') && ($seq2[$a] eq 'T')) { $ti++; }
elsif (($seq1[$a] eq 'T') && ($seq2[$a] eq 'C')) { $ti++; }
else { $tv++; }

} # -------------------------------------------------------------------








#check if blast database exists
sub check_db {
`ls /home/wicker/data/databases/blast_databases > templist`;

open (IN, "<templist");
$exist = 0;
while (<IN>){ 
        ($ba) = /^($chr2)\./;
        if ($ba) {
                $exist = 1;
                }
        }
close (IN);

if ($exists ==1) {
        print "database exists\n";
        }
if ($exists ==0) {
        print "make database $chr2\n";
        `mk_db_DNA $chr2`;
        }

}
